---
title: "Benchmark - COTAN V.2"
author: "Analyses author: Jakub Kubiś"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
  
  
---

\



```{r include = FALSE}


# https://github.com/seriph78/COTAN/tree/devel

library(COTAN)
library(zeallot)
library(rlang)
library(data.table)
library(Rtsne)


options(parallelly.fork.enable = TRUE)
```





```{r include = FALSE}


# Analytical pipeline

# Initialize the `COTAN` object with the row count table and
# the metadata for the experiment.

cond <- "benchmark test"



library(CSSG.toolkit)

sc_project <- create_project(sparse_matrix_path = '../benchmark/data/', sparse_name = 'matrix', rows_name = 'genes', cols_name = 'barcodes', type = 'norm')



colnames(sc_project@matrices$norm) <- make.unique(colnames(sc_project@matrices$norm))

obj <- COTAN(raw = as.data.frame(sc_project@matrices$norm))
obj <- initializeMetaDataset(obj,
                             GEO = NULL,
                             sequencingMethod = "Drop_seq",
                             sampleCondition = cond)


```



\

#### Min-Max genes thresholds


```{r   include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}

library(Seurat)




# create seurat object
UMI <- CreateSeuratObject(counts = sc_project@matrices$norm)

# put into normalized
UMI@assays$RNA$data <- UMI@assays$RNA$counts

thresholds <- outlires(UMI@meta.data$nFeature_RNA)


thresholds$plot

```



\

#### Features number


```{r   include=FALSE}



genesSizeHighThr <- thresholds$thresholds[length(thresholds$thresholds)]
obj <- addElementToMetaDataset(obj, "Num genes high threshold", genesSizeHighThr)

cells_to_rem <- getCells(obj)[getNumExpressedGenes(obj) > genesSizeHighThr]
obj <- dropGenesCells(obj, cells = cells_to_rem)



genesSizeLowThr <- thresholds$thresholds[1]
obj <- addElementToMetaDataset(obj, "Num genes low threshold", genesSizeLowThr)

cells_to_rem <- getCells(obj)[getNumExpressedGenes(obj) < genesSizeLowThr]
obj <- dropGenesCells(obj, cells = cells_to_rem)

```


```{r   include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}


plot(genesSizePlot(obj))

```



\

##### Mitochondrial genes [%]


```{r   include=FALSE}
c(mitPlot, mitSizes) %<-% mitochondrialPercentagePlot(obj, genePrefix = "^MT")


mitPercThr <- 20
obj <- addElementToMetaDataset(obj, "Mitoc. perc. threshold", mitPercThr)

cells_to_rem <- rownames(mitSizes)[mitSizes[["mit.percentage"]] > mitPercThr]
obj <- dropGenesCells(obj, cells = cells_to_rem)

c(mitPlot, mitSizes) %<-% mitochondrialPercentagePlot(obj, genePrefix = "^MT")

```

```{r   include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}


plot(mitPlot)
```




```{r include=FALSE}
genes_to_rem <- getGenes(obj)[grep("^MT", getGenes(obj))]
cells_to_rem <- getCells(obj)[which(getCellsSize(obj) == 0L)]

obj <- dropGenesCells(obj, genes_to_rem, cells_to_rem)
```



\

##### PCA plot

```{r include=FALSE}


obj <- clean(obj)

c(pcaCellsPlot, pcaCellsData, genesPlot,
  UDEPlot, nuPlot, zoomedNuPlot) %<-% cleanPlots(obj)

```

```{r   include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}

plot(pcaCellsPlot)
```







```{r include=FALSE}

# ## COTAN analysis
# 
# In this part, all the contingency tables are computed
# and used to get the statistics necessary to `COEX` evaluation and storing


obj <- proceedToCoex(obj, calcCoex = TRUE,
                     optimizeForSpeed = TRUE, cores = 6L, deviceStr = "cpu",
                     saveObj = FALSE, outDir = outDir)
```

```{r include=FALSE}


# Analysis of the elaborated data

## GDI
## Uniform Clustering

# It is possible to obtain a cell clusterization based on the concept of 
# *uniformity* of expression of the genes across the cells.
# That is the cluster satisfies the null hypothesis of the `COTAN` model:
# the genes expression is not dependent on the cell in consideration.
# 
# There are two functions involved into obtaining a proper clusterization:
# the first is `cellsUniformClustering` that uses standard tools clusterization
# methods, but then discards and re-clusters any *non-uniform* cluster.
# 
# Please note that the most important parameters for the users are the
# `GDIThreshold`s inside the **Uniform Transcript** checkers: they define how 
# strict is the check. Default constructed advance check gives a pretty strong
# guarantee of uniformity for the *cluster*.

# This code is a little too computationally heavy to be used in an example
# So we stored the result and we can load it in the next section

# default constructed checker is OK
# advChecker <- new("AdvancedGDIUniformityCheck")

c(splitClusters, splitCoexDF) %<-%
  cellsUniformClustering(obj, initialResolution = 0.6, checker = NULL,
                         optimizeForSpeed = FALSE, deviceStr = "cpu",
                         cores = 6L, genesSel = "HVG_Seurat",
                         saveObj = FALSE)

obj <- addClusterization(obj, clName = "split",
                         clusters = splitClusters, coexDF = splitCoexDF)

table(splitClusters)
```

\

#### UMAP plot - COTAN clusters


```{r  include=FALSE}
c(umapPlot, cellsPCA) %<-% cellsUMAPPlot(obj,
                                         dataMethod = "LogLikelihood",
                                         genesSel = "HVG_Seurat",
                                         colors = NULL, numNeighbors = 30L,
                                         minPointsDist = 0.2)

```


```{r  include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}


plot(umapPlot)
```



\

#### UMAP Plot – Clusters from COTAN Approach Visualized with Seurat-Based Dimensionality Reduction (UMAP/PCA)


```{r  include=FALSE}
UMI[['MitoPercent']] <- PercentageFeatureSet(UMI, pattern = "^MT-") + PercentageFeatureSet(UMI, pattern = "^Mt-") + PercentageFeatureSet(UMI, pattern = "^mt-")

UMI <- subset(UMI, subset = nFeature_RNA > thresholds$thresholds[1] & nFeature_RNA <= thresholds$thresholds[length(thresholds$thresholds)]
 & MitoPercent < 20)




UMI <- FindVariableFeatures(UMI, selection.method = "vst", nfeatures = 5000, binning.method = 'equal_frequency')



all.genes <- rownames(UMI)
UMI <- ScaleData(UMI, features = all.genes)

UMI <- RunPCA(UMI, features = VariableFeatures(object = UMI))


Elbow <- ElbowPlot(UMI, ndims = 50)

dims <- as.data.frame(Elbow$data$stdev)

#select the most variable reduction

dim <- dim_reuction_pcs(dims)



UMI <- JackStraw(UMI, num.replicate = 10, dims = dim)
UMI <- ScoreJackStraw(UMI, dims = 1:dim)

#Select significient PCs
jc <- as.data.frame(UMI@reductions$pca@jackstraw@overall.p.values)
jc <- jc[jc$Score < 0.05,]
dim <- as.vector(jc$PC)


UMI <- RunUMAP(UMI, dims = dim)


Idents(UMI) <- obj@metaCells$CL_split

umap_plot <- DimPlot(UMI, reduction = "umap", raster = FALSE)

svg("umap_COTAN.svg", width = 12, height = 8) 

umap_plot

dev.off()

```


```{r  include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}

plotly::ggplotly(umap_plot)

```



```{r  include=FALSE}





sc_project <- create_project_from_seurat(UMI)



```


\

#### Cells content in COTAN clusters [n]


```{r  include=FALSE}




data <- bin_cell_test(p_val = 0.05, names = sc_project@names$primary, min_cells = 20)

threshold <- cell_stat_graph(data$data)

svg("threshold_COTAN.svg", width = 8, height = 10) 

threshold

dev.off()

```



```{r  include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}

threshold


```



\

#### Markers table

\

```{r   include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}


# cluster markers selection - wilcox

library(MAST)

markers <-FindAllMarkers(UMI,
                     only.pos = TRUE,
                     min.pct = 0.10,
                     logfc.threshold = 0.10,
                     test.use = "MAST") 


write.csv(markers, 'COTANr_cluster_markers.csv', quote = FALSE)


DT::datatable(markers, filter = "top", options = list(pageLength = 10))

```

\

#### Top 2 markers for conCluster clusters

```{r   include=FALSE}


library(dplyr)

top <- markers %>%
  group_by(cluster) %>%
  arrange(cluster, desc(avg_log2FC), p_val) %>%  
  slice_head(n = 2)

sc_project@names$subtypes <- sc_project@names$primary



plot <- marker_heatmap(sc_project, type = 'subtypes', markers = top$gene, angle_col = 270, fontsize_row = 7, fontsize_col = 7, font_labels = 8, clustering_method = 'complete', x_axis = 'Cells', y_axis = 'Genes [log(CPM +1)]')


svg("heat_COTAN.svg", width = 11, height = 9) 

plot

dev.off()

```


```{r   include=TRUE, echo=FALSE, warning=FALSE, message=FALSE}


plot

```